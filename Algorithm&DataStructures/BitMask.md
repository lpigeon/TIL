# BitMask
비트마스크란 컴퓨터의 자료처리의 특성을 이용하여 획기적으로 빠른 연산 속도를 사용하는 것을 말한다.
즉, 컴퓨터는 내부적으로 0과 1로써 연산을 수행하므로 모든 자료를 이진수로 처리함을 의미한다. <br>

## 기본적인 비트 연산자
* AND , &<br>
두 비트가 주어줬을 때, 모두 1이여야 1반환
* OR , |<br>
두 비트가 주어줬을 때, 하나라도 1이여야 1반환
* XOR , ^<br>
두 비트가 주어줬을 때, 서로 달라야 1반환
* NOT , ~<br>
두 비트가 주어줬을 때, 서로 달라야 1반환
* SHIFT , << , >><br>
<< : 왼쪽으로 비트 옮김<br>
\>> : 오른쪽으로 비트 옮김

## 개념
예를 들어, DFS & BFS를 사용한다 할 때, visted = [False]*n을 사용하여 방문을 체크한다. 이것을 비트마스크로 표현하면 더욱 간결하고 획기적인 속도로 처리 할 수 있다. 코드로 표현해보면 다음과 같다.
```python
visted = 0b0000000000 # 방문할 곳이 10곳이라 한다면
```
여기서 각각의 비트는 방문 노드라고 생각할 수 있다.

## 활용
그렇다면 어떤식으로 비트를 추가 및 삭제 또는 다른 상태로 바꿀 수 있을까? 위 visted를 사용하여 알아보자. <br>
1. 원소 추가<br>
visted에 n번 노드에 방문 체크를 한다고 가정해 보자. <br>(첫 노드는 0이 아니라 1이라고 가정)
```python
visted |= (1 << n)
```
OR연산자를 사용하면 구현 할 수 있다.<br>

2. 원소 삭제<br>
visted에 n번 노드에 방문 해체를 한다고 가정해 보자. <br>
```python
visted &= (1 << n)
```
AND연산자를 사용하면 구현 할 수 있다.<br>

3. 원소 토글(Toggle)<br>
visted에 n번 노드가 방문해 있으면 해체하고 방문 안했으면 방문을 한다고 가정해 보자. <br>
```python
visted ^= (1 << n)
```
XOR연산자를 사용하면 구현 할 수 있다.

4. 비우기 및 채우기<br>
visted에 모든 노드를 방문 해체 또는 방문 체크 한다고 가정해 보자. <br>
```python
visted = 0              #비우기
visted = (1 << n+1) - 1  #채우기
```
채우기에 경우 n보다 1만큼 큰 공간에 1을 채우고 전체에서 1을 빼주면 이진수의 계산에 의해 n공간이 모두 1로 채워진다.

5. 원소 체크<br>
visted에 n번 노드에 방문되어 있는지를 체크 한다고 가정해 보자. <br>
```python
print(1 if visted & (1 << n) != 0 else 0))
```

### 참고
* https://velog.io/@1998yuki0331/Python-%EB%B9%84%ED%8A%B8-%EB%A7%88%EC%8A%A4%ED%82%B9-%EC%A0%95%EB%A6%AC